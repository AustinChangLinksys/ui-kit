-----

# üìú Flutter UI Component Library Charter (ui\_kit)

**Version**: 3.1.1
**Effective Date**: 2025-12-09
**Scope**: All contributors and maintainers of the UI Library

-----

## 1\. Vision & Scope

This library aims to provide a **High Cohesion, Logic-Free, Configurable** set of UI components. It serves as the **Single Source of Truth** for the application's visual presentation, supporting **Multi-Paradigm Visual Styles** (e.g., Flat, Glass, Pixel, Neumorphic) through a unified configuration system.

  * **Scope**: Atomic components (Atoms), composite components (Molecules), theme definitions (Theming), icon assets (Assets), interaction systems (Motion/Feedback), and layout logic.
  * **Out of Scope**: API connectivity, state management (Bloc/Provider), routing logic, and business data models.

-----

## 2\. Architectural Boundaries

### 2.1 Physical Isolation

The library must exist as an **independent Dart Package**, physically enforced to decouple it from the main app.

### 2.2 Dependency Hygiene

  * ‚ùå **Forbidden**: Dependencies containing business logic or backend connectivity are strictly prohibited (e.g., `bloc`, `provider`, `riverpod`, `http`, `dio`, `firebase`, `shared_preferences`).
  * ‚úÖ **Allowed**: UI and utility packages only (e.g., `flutter`, `intl`, `vector_math`, `google_fonts`, `flutter_svg`, `rive`, `theme_tailor`, `flutter_animate`, `flutter_gen`).

### 2.3 Directory Structure

Adopts a variation of **Atomic Design**:

  * `src/foundation/`: Base styles (Theme Contracts, Colors, Motion, Feedback, Specs).
  * `src/atoms/`: Indivisible minimal units (AppSurface, Button, Icon).
  * `src/molecules/`: Simple combinations (ListTile, InputField, Toggles).
  * `src/organisms/`: Complex blocks (AppBar, ProductCard, BottomSheet).
  * `src/layout/`: Responsive layout helpers.

-----

## 3\. Architectural Core Principles

To maintain long-term maintainability and support multi-style switching, all development must adhere to the following philosophies.

### 3.1 Inversion of Control (IoC)

  * **Definition**: Components must not determine their own specific appearance. Control is inverted to the **Theme**.
  * **Practice**: Components ask the Theme "How should I look?" (e.g., color, shape), never "Who are you?" (e.g., "Are you Brutal style?").

### 3.2 Data-Driven Strategy (DDS)

  * **Definition**: Eliminate hard-coded logic branches when handling structural differences. Use data structures (Specs) instead.
  * **Practice**: Use the **Renderer Pattern**. Components render content based on data within a Spec (e.g., `ToggleStyle`), not `if/else` statements.

### 3.3 Zero Internal Defaults

  * **Definition**: Components **MUST NOT** contain fallback values or default style methods.
  * **Fail Fast**: If a required `ThemeExtension` is missing, the component must explicitly throw an exception to force a configuration fix.

### 3.3.1 Default Value Type Classification

To clarify the scope of Section 3.3, defaults are categorized as follows:

  * **Style Defaults** ‚ùå **PROHIBITED**: Any default values that affect visual appearance, theming, or styling.
    ```dart
    // ‚ùå VIOLATION: Style defaults
    final Color color = widget.color ?? Colors.blue;
    final BorderRadius radius = widget.radius ?? BorderRadius.circular(8);
    static const TextStyle defaultTextStyle = TextStyle(fontSize: 14);
    ```

  * **API Behavior Defaults** ‚úÖ **ALLOWED**: Default values that control component functional behavior, not appearance.
    ```dart
    // ‚úÖ COMPLIANT: API behavior defaults
    final bool scrollable = widget.scrollable ?? true;
    final bool useSlivers = widget.useSlivers ?? true;
    final bool useContentPadding = widget.useContentPadding ?? true;
    ```

  * **Rationale**: API behavior defaults enhance usability and follow Flutter ecosystem conventions, while style defaults violate the Inversion of Control principle by making visual decisions independently of the theme system.

### 3.4 Configuration Injection

  * **Definition**: The generation of the Theme and Color System must strictly adhere to the **"Configuration Priority"** principle.
  * **Rule**:
      * **High Priority (Override)**: Explicit override values passed via `AppThemeConfig` (e.g., `customSemanticSuccess`, `primary`) must always take precedence.
      * **Low Priority (Derived)**: Derived values generated by the Factory algorithm based on `Seed Color` are only used when no override is present.
  * **Rationale**: Supports both **"Lazy Mode"** (Seed-based generation) and **"Expert Mode"** (Full Customization).

-----

## 4\. Theming & Styling

### 4.1 The Single Source of Truth: AppColorScheme

  * **Rule**: All color access within the system **MUST** occur exclusively through the `AppColorScheme` interface (which unifies Material Standard and App Semantic colors) OR the synchronized Material `ColorScheme`.
  * **Constraint**:
      * ‚ùå **Strictly Prohibited**: Using hardcoded colors like `Colors.red` or `Colors.black` in widgets.
      * ‚úÖ **Permitted**: Using Flutter's native `ColorScheme` (`Theme.of(context).colorScheme`) is allowed, as it is synchronized with `AppColorScheme`.
      * ‚úÖ **Preferred**: Use `AppColorScheme` when semantic precision (e.g., `styleBackground`, `semanticSuccess`) is required.

### 4.2 Semantic Layer Architecture

  * **Rule**: Non-Material colors must be categorized into five distinct semantic layers. Mixing layers is prohibited:
    1.  **Structure**: `highContrastBorder`, `subtleBorder`, `styleBackground` (Defines shape/boundaries).
    2.  **Decoration**: `styleShadow`, `glowColor` (Defines depth/lighting).
    3.  **Semantic Status Colors**: `semanticSuccess`, `semanticWarning`, `semanticDanger`, `semanticGlow` (Defines status state).
    4.  **State**: `activeFillColor`, `activeContentColor` (Defines interaction feedback).
    5.  **Utility**: `overlayColor` (Defines atmosphere/masking).
  * **Constraint**: **Color Harmonization** is mandatory for Semantic Status and Barrier colors. Pure raw colors (e.g., pure Green/Red) are forbidden; they must be blended with the `Seed Color` to ensure visual consistency.

### 4.3 Design Style Strategies

  * **Rule**: The UI Kit must support and strictly distinguish between five rendering strategies. Widgets must respond to `AppTheme.style` with distinct behaviors:
      * **Flat**: Relies on solid color blocks and standard radii.
      * **Glass**: Relies on Opacity, Blur, and Glow. **Constraint**: Background visibility is mandatory.
      * **Brutal**: Relies on Bold Borders, Solid Colors, and High Contrast. **Constraint**: Uses thick borders and offset shadows for visual impact.
      * **Pixel**: Relies on Solid Colors, High Contrast Borders, and Aliased shapes. **Constraint**: Gradients and Blur are strictly prohibited.
      * **Neumorphic**: Relies on Double Shadows (Light/Dark) and Embossed/Debossed effects.

### 4.4 Global Visual Effects

  * **Rule**: An `AppEffectLayer` must be injected at the application root to simulate medium textures.
      * **Glass Mode**: Must apply a **Noise Overlay** to prevent color banding.
      * **Pixel Mode**: Must apply a **CRT Shader** (Scanlines, Vignette, RGB Split).

### 4.5 Automation & Tooling

  * **Theme Tailor**: The `theme_tailor` package with **`@TailorMixin`** MUST be used to generate `ThemeExtension` classes. Hand-writing `copyWith` and `lerp` is prohibited.

### 4.6 Shared Specs Architecture

Component styles MUST compose shared specs instead of duplicating properties.

#### 4.6.1 Shared Specs

| Spec | Purpose | Location |
|------|---------|----------|
| `AnimationSpec` | Duration + Curve for animations | `specs/shared/animation_spec.dart` |
| `StateColorSpec` | State-based color resolution (active/inactive/disabled/error/hover/pressed) | `specs/shared/state_color_spec.dart` |
| `OverlaySpec` | Scrim color + blur + animation for overlays | `specs/shared/overlay_spec.dart` |

#### 4.6.2 Composition Pattern

```dart
// ‚ùå BAD: Duplicating animation properties
@TailorMixin()
class MyComponentStyle extends ThemeExtension<MyComponentStyle> {
  final Duration animationDuration; // Duplicated!
  final Curve animationCurve;       // Duplicated!
  final Color activeColor;          // Duplicated!
  final Color inactiveColor;        // Duplicated!
}

// ‚úÖ GOOD: Compose shared specs
@TailorMixin()
class MyComponentStyle extends ThemeExtension<MyComponentStyle> {
  final AnimationSpec animation;     // Composed
  final StateColorSpec colors;       // Composed
  final double customProperty;       // Component-specific only
}
```

#### 4.6.3 AnimationSpec Presets

| Preset | Duration | Curve | Use Case |
|--------|----------|-------|----------|
| `AnimationSpec.instant` | 0ms | linear | Pixel theme, reduced motion |
| `AnimationSpec.fast` | 150ms | easeOut | Micro-interactions, hover states |
| `AnimationSpec.standard` | 300ms | easeInOut | Default transitions |
| `AnimationSpec.slow` | 500ms | easeInOut | Hero animations, emphasis |

#### 4.6.4 StateColorSpec Usage

```dart
// In component - resolve color based on state
final color = style.textColors.resolve(
  isActive: isSelected,
  isDisabled: !isEnabled,
  hasError: hasValidationError,
  isHovered: _isHovered,
  isPressed: _isPressed,
);
// Resolution priority: error ‚Üí disabled ‚Üí pressed ‚Üí hover ‚Üí active/inactive
```

#### 4.6.5 OverlaySpec Presets

| Preset | Scrim | Blur | Animation | Theme |
|--------|-------|------|-----------|-------|
| `OverlaySpec.standard` | black54 | 0.0 | standard | Flat, Neumorphic |
| `OverlaySpec.glass` | black26 | 10.0 | slow | Glassmorphism |
| `OverlaySpec.pixel` | black87 | 0.0 | instant | Pixel art |

### 4.7 StyleOverride Mechanism

  * **Rule**: Components SHOULD support local style overrides via `StyleOverride` InheritedWidget.
  * **Resolution Priority**:
    1. Component parameter (e.g., `animationOverride`)
    2. `StyleOverride` ancestor (nearest in widget tree)
    3. Theme default (from `AppDesignTheme`)

```dart
// Page-level override for faster animations
StyleOverride(
  animationSpec: AnimationSpec.fast,
  child: SettingsPage(),
)

// Component respects override
AnimationSpec _resolveAnimation(BuildContext context) {
  if (animationOverride != null) return animationOverride!;
  final override = StyleOverride.resolveSpec<AnimationSpec>(context);
  if (override != null) return override;
  return theme.carouselStyle.animation;
}
```

### 4.8 Unified SheetStyle

  * **Rule**: `SheetStyle` is the single source of truth for both bottom sheets and side sheets.
  * **Removed**: `BottomSheetStyle` and `SideSheetStyle` are deprecated and removed.

```dart
// ‚úÖ GOOD: Use unified SheetStyle
final duration = theme.sheetStyle.overlay.animation.duration;
final width = theme.sheetStyle.width;

// ‚ùå REMOVED: Old separate styles
// theme.bottomSheetStyle  // REMOVED
// theme.sideSheetStyle    // REMOVED
```

### 4.9 Typography

  * Follow the **DRY Principle**. Create a unified `BaseTextStyle` to manage `fontFamily` and package paths.

#### 4.9.1 The Single Source of Truth: appTextTheme

  * **Rule**: Text styling within Design Theme files **SHOULD** occur through the `appTextTheme` object defined in `app_typography.dart` or the standard `Theme.of(context).textTheme`.
  * **Constraint**:
      * ‚ùå **Strictly Prohibited**: Using hardcoded `TextStyle()` with manual `fontSize`, `fontWeight`, `fontFamily` in Design Theme files.
      * ‚ùå **Strictly Prohibited**: Defining inline text styles in component Spec definitions.
  * **Practice**: Use `appTextTheme.<variant>!.copyWith(color: scheme.onSurface)` or `Theme.of(context).textTheme.<variant>` pattern.

#### 4.9.2 Theme Synchronization

  * **Rule**: `appTextTheme` is automatically synchronized with Flutter's `Theme.of(context).textTheme` through `AppTheme.create()`.
  * **Implementation**: `AppTheme.create()` applies `appTextTheme` directly to `ThemeData.textTheme` with color adjustments.
  * **Implication**: Components may use **either** `appTextTheme` or `Theme.of(context).textTheme` - they reference the same typography system.
  * **Equivalence**:
    ```dart
    // These are equivalent:
    Theme.of(context).textTheme.bodySmall
    appTextTheme.bodySmall
    ```

#### 4.9.3 Typography Token Mapping

| Token | Size | Weight | Usage |
|-------|------|--------|-------|
| `displayLarge` | 57px | w400 | Hero text |
| `headlineLarge` | 32px | w700 | Page titles |
| `titleMedium` | 16px | w700 | Section headers, Brutal table headers |
| `labelLarge` | 14px | w700 | Bold labels, table headers |
| `labelMedium` | 12px | w700 | Small bold text, Pixel toast |
| `bodyMedium` | 14px | w400 | Body text, table cells, breadcrumbs |
| `bodySmall` | 12px | w400 | Captions |

#### 4.9.4 Theme-Specific Typography Customization

  * **Rule**: Themes may customize typography via `.copyWith()` while preserving the base token.
  * **Examples**:
      * **Pixel Theme**: `appTextTheme.labelLarge!.copyWith(fontFamily: 'Courier')` for retro monospace effect.
      * **Brutal Theme**: Use `titleMedium` (16px) for headers instead of `labelLarge` (14px) for bolder impact.
      * **Neumorphic Theme**: Use `onSurfaceVariant` color for subdued headers.

-----

## 5\. Interaction & Immersion

### 5.1 The Unified Motion System

  * **Rule**: Animation durations and curves **MUST NOT** be hardcoded. They must be retrieved via the `AppMotion` interface (`motion.fast`, `motion.medium`, `motion.slow`).
  * **Style-Aware Behavior**: Motion physics must adapt to the active Design Style:
      * **Pixel Mode**: Must enforce **0ms (Instant Snap)** or **Stepped Curves**. Interpolation is strictly prohibited.
      * **Glass Mode**: Must use Fluid curves (`easeOutExpo`) with longer durations to simulate floating/underwater physics.
      * **Flat/Neumorphic**: Uses standard Material Easing.

### 5.2 The Feedback System

  * **Rule**: All interactive components (Buttons, Toggles, Inputs, Table Edit) must request feedback via the `AppFeedback` interface upon user interaction.
  * **Constraint**:
      * **Pixel Mode**: Must provide **"Heavy Impact"** (strong haptic) and Mechanical/8-bit audio feedback.
      * **Glass Mode**: Must provide **"Crisp/Light"** (light haptic) and Glass/Ethereal audio feedback.

-----

## 6\. Component Design & Primitives

### 6.1 The Primitive: AppSurface

  * **Mandatory Usage**: All visual containers **MUST** compose `AppSurface` as the root or child node.
  * **No Native Containers**: Business components must not directly use `Container` + `BoxDecoration`.

### 6.1.1 Container Type Classification

To clarify the scope of Section 6.1, containers are categorized as follows:

  * **Visual Containers** ‚Üí **MUST use AppSurface**: Components that create visual surfaces, decorations, or styled presentations.
    ```dart
    // ‚ùå VIOLATION: Visual container using native decoration
    Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [BoxShadow(...)],
      ),
      child: content,
    )

    // ‚úÖ COMPLIANT: Visual container using AppSurface
    AppSurface(
      style: theme.cardStyle,
      child: content,
    )
    ```

  * **Structural Containers** ‚Üí **MAY use System Widgets**: Components that provide layout logic, system integration, or architectural scaffolding without visual decoration.
    ```dart
    // ‚úÖ COMPLIANT: Structural container for page layout
    Scaffold(
      backgroundColor: backgroundColor,
      body: contentLayer,
      bottomNavigationBar: bottomNavigationBar,
      floatingActionButton: floatingActionButton,
    )

    // ‚úÖ COMPLIANT: Layout management
    Row(children: [...])
    Column(children: [...])
    SafeArea(child: content)
    ```

  * **Examples by Category**:
    - **Visual**: Cards, Buttons, Chips, Badges, Dialogs, Sheets, Surfaces with styling
    - **Structural**: Page layouts, Grid systems, Responsive wrappers, Navigation scaffolding

  * **Rationale**: Visual containers require theme integration and consistent styling across design systems, while structural containers serve architectural purposes and may need to leverage Flutter's native layout and system integration capabilities.

### 6.2 Dumb Components

  * Components receive data via **Constructor** and pass events via **Callback**. They must not hold business state.

### 6.3 Composition over Inheritance

  * Use the **Slots Pattern** (e.g., `child`, `leading`, `trailing`). Avoid monolithic widgets.

### 6.4 Overlay Component Wrapper Requirements

  * **Rule**: Modal overlays (`showAppDialog`, `showAppBottomSheet`) **MUST** wrap content with the following hierarchy:
    ```
    Theme ‚Üí Portal ‚Üí Material ‚Üí Content
    ```
  * **Rationale**:
      * **Theme**: Ensures design tokens are available in the overlay context.
      * **Portal**: Required for `flutter_portal` based components (e.g., `AppDropdown`) to function.
      * **Material**: Required for Material-based widgets (e.g., `TextField`, `InkWell`) to render correctly.
  * **Constraint**: Never assume the calling context provides these wrappers. Overlays must be self-contained.

-----

## 7\. Expansion Protocols

### 7.1 Component Expansion

  * **Composition First**: Prioritize using `AppSurface`.
  * **No Runtime Checks**: Code **MUST NOT** contain checks like `if (theme is BrutalDesignTheme)`. Use the Renderer Pattern.

### 7.2 Style Expansion

  * **Zero-Touch Policy**: Adding a new style **MUST NOT** require modifying the source code of existing components.
  * **Full Compliance**: New styles must fully implement `AppDesignTheme` and `AppColorScheme`.

-----

## 8\. Assets Management

### 8.1 Access Control

  * **Strong Typing**: String paths are prohibited. Use objects generated by **`flutter_gen`** (e.g., `MyAssets.icons.home`).

### 8.2 Formats

#### 8.2.1 Icon System Architecture

  * **Primary**: Use **SVG** assets via `AppIcon(SvgGenImage)` for theme-adaptive styling.
  * **Secondary**: Material Icons via `AppIcon.font(IconData)` are **permitted** for standard symbols.
  * **Equivalence**: Both approaches support theme-based color control via `IconTheme`.

#### 8.2.2 Icon Implementation Guidelines

  * **SVG Preferred**: For custom icons, brand assets, or theme-specific variations.
  * **Material Icons Acceptable**: For standard UI symbols (e.g., `Icons.close`, `Icons.expand_more`).
  * **Pixel Mode**: Both SVG and font icons must adapt via `AppIcon` logic for pixelated rendering.

#### 8.2.3 Usage Examples

```dart
// ‚úÖ PREFERRED: SVG asset
AppIcon(Assets.icons.close)

// ‚úÖ ACCEPTABLE: Material font icon
AppIcon.font(Icons.close)

// ‚ùå PROHIBITED: Direct Icon widget without theme integration
Icon(Icons.close)
```

-----

## 9\. Animation Strategy

  * **Micro-interactions**: Use `flutter_animate`.
  * **State-Driven**: Use **Rive**.
  * **Prohibited**: Lottie is not used.

-----

## 10\. Layout & Responsiveness

  * **No Global State**: Use `LayoutBuilder` or `MediaQuery`, never Singletons.
  * **Centralized Config**: Breakpoints and Gutters must be defined in `AppLayout` ThemeExtension.

### 10.1 Responsive Breakpoints

| Breakpoint | Width Range | Primary Use Case |
|------------|-------------|------------------|
| Mobile | < 600px | Single column, bottom sheets |
| Tablet | 600px - 1200px | Dual column, side sheets |
| Desktop | > 1200px | Multi-column, inline dialogs |

### 10.2 Responsive Edit Mode Strategy

  * **Rule**: Components with edit modes (e.g., Tables) must adapt their editing UX based on screen size.
  * **Desktop (>1200px)**: Inline editing with Save/Cancel buttons directly in the component.
  * **Tablet (600-1200px)**: Modal dialogs for edit forms.
  * **Mobile (<600px)**: Full-screen bottom sheets for edit forms.
  * **Constraint**: Edit action buttons must conditionally render based on `isEditing && isDesktop`.

-----

## 11\. Accessibility & Internationalization

  * **A11y**: Interactive components must wrap `Semantics`. Minimum touch target 44px/48px.
  * **i18n**: No hardcoded strings. All labels must be passed via constructor.

-----

## 12\. Performance

  * **Repaint Boundary**: Wrap frequently changing components (e.g., Loaders) in `RepaintBoundary`.
  * **Expensive Operations**: Use `Opacity` and `BackdropFilter` sparingly (except where mandated by Glass Style).

-----

## 13\. Quality Assurance & Testing

### 13.1 Widgetbook

  * **Mandatory**: All public components must have a UseCase in Widgetbook with configurable Knobs.
  * **File Naming Convention**: Widgetbook story files **MUST** use the suffix `.stories.dart` (e.g., `app_button.stories.dart`, `app_styled_text.stories.dart`).
  * **Directory Structure**: Stories must be organized by atomic level: `widgetbook/lib/stories/{atoms|molecules|organisms}/`.

### 13.2 Golden Tests

  * **Test Matrix**: Light/Dark x Flat/Glass/Pixel/Neumorphic x Scale 1.0/1.5.
  * **Safe Mode Protocol**: (See Appendix B).

### 13.3 Theme Editor

  * **Integration Verification**: Components must update instantly when theme parameters change in the Theme Editor, verifying adherence to IoC.

-----

## 14\. Governance

### 14.1 Constitution Version

3.1.0

### 14.2 Ratification Date

2025-12-08

### 14.3 Amendment Procedure

Amendments require consensus among core maintainers.

### 14.4 Compliance Review

Adherence will be reviewed during code reviews. Non-compliance must be resolved promptly.

-----

## Appendix A: Developer Implementation Guide

### A.1 Style-Aware Colors

```dart
// ‚úÖ GOOD: Using Semantic Colors
Container(
  decoration: BoxDecoration(
    color: theme.appColors.styleBackground,
    border: Border.all(color: theme.appColors.highContrastBorder),
  )
)
```

### A.2 Unified Motion

```dart
// ‚úÖ GOOD: Using Motion Tokens
AnimatedContainer(
  duration: theme.motion.medium.duration, // 0ms for Pixel, 500ms for Glass
  curve: theme.motion.medium.curve,
  ...
)
```

### A.3 Typography in Design Themes

```dart
// ‚úÖ GOOD: Using appTextTheme tokens
tableStyle: TableStyle(
  headerTextStyle: appTextTheme.labelLarge!.copyWith(color: scheme.onSurface),
  cellTextStyle: appTextTheme.bodyMedium!.copyWith(color: scheme.onSurface),
),

// ‚úÖ GOOD: Theme-specific customization preserving base token
breadcrumbStyle: BreadcrumbStyle(
  itemTextStyle: appTextTheme.labelLarge!.copyWith(fontFamily: 'Courier'), // Pixel theme
),

// ‚ùå BAD: Hardcoded TextStyle
tableStyle: TableStyle(
  headerTextStyle: TextStyle(
    fontFamily: 'NeueHaasGrotTextRound',
    fontWeight: FontWeight.bold,
    fontSize: 14,
  ),
),
```

### A.4 Overlay Component Implementation

```dart
// ‚úÖ GOOD: Proper wrapper hierarchy in showAppDialog
pageBuilder: (dialogContext, animation, secondaryAnimation) {
  return Theme(
    data: themeData,
    child: Portal(
      child: Material(
        type: MaterialType.transparency,
        child: builder(dialogContext),
      ),
    ),
  );
},
```

-----

## Appendix B: Golden Test Standard Protocol

**Goal**: To ensure the **Stability**, **Consistency**, and **Readability** of visual regression tests across the entire UI library.

### B.1 Core Architecture

All Golden Test files must adhere to the following structure to ensure proper resource loading and test matrix generation.

```dart
void main() {
  // 1. Global Setup
  setUpAll(() async {
    // MUST load real fonts. Using Ahem (colored blocks) is prohibited.
    await loadAppFonts();
  });

  group('Component Golden Tests', () {
    // 2. Use the Matrix Factory
    // You MUST use the matrix to generate all 8 styles (4 Themes x 2 Modes) at once.
    goldenTest(
      'Component - State Name',
      fileName: 'component_state_name',
      builder: () => buildThemeMatrix(
        name: 'State Name',
        width: 300.0, // Provide explicit width
        height: 100.0,
        child: ComponentUnderTest(...),
      ),
    );
  });
}
```

### B.2 Safe Mode Protocol

To prevent CI/CD failures, all test scenarios generated by `buildThemeMatrix` (and the underlying `buildSafeScenario`) must enforce the following protections:

1.  **Explicit Constraints (Size Lock)**

      * **Rule**: Every test scenario **MUST** be wrapped in a fixed-size container (e.g., `SizedBox`).
      * **Reason**: Prevents `RenderFlex overflow` errors and `BoxConstraints(biggest)` infinite expansion crashes.
      * **Standard Sizes**:
          * Buttons/Inputs: `width: 300`, `height: 100`
          * Cards: `width: 300`, `height: auto`
          * Screens/Pages: `width: 375`, `height: 667`

2.  **Background Visibility**

      * **Rule**: Every scenario **MUST** wrap the component in a `ColoredBox` injected with `theme.scaffoldBackgroundColor` (derived from `AppColorScheme.styleBackground` or similar).
      * **Reason**:
          * **Glass Theme**: Requires a colored background to show translucency and blur.
          * **Neumorphic Theme**: Requires specific grey tones to show shadow depth.
          * **Pixel Theme**: Requires contrast to show the aliased borders.
          * Transparent backgrounds make these themes invisible or incorrect in screenshots.

3.  **Animation Freezing**

      * **Rule**: Scenarios are wrapped in `TickerMode(enabled: false)` by default.
      * **Exception**: If testing an active animation sequence (e.g., Tooltip popping up), animation must be explicitly enabled, and time must be advanced manually via `pump()`.
      * **Reason**: Prevents timeouts caused by infinite looping animations (e.g., `AppSkeleton` pulse, `AppLoader` spin) blocking `pumpAndSettle`.

### B.3 Interaction Strategy

For components requiring interaction to appear (e.g., Tooltips, Dialogs), prioritize **State Injection** over simulation.

  * **‚úÖ Recommended: State Injection**
      * Expose an `initiallyVisible` or `forceState` parameter in the component.
      * Usage: `AppTooltip(initiallyVisible: true, ...)`
      * **Benefit**: 100% stability, zero race conditions.
  * **‚ö†Ô∏è Alternative: Simulated Interaction**
      * Use only when State Injection is impossible.
      * Must use the `pumpWidget` callback to manually trigger the event.

-----

## Appendix C: Code Review Checklist

Reviewers shall inspect code based on the following:

  * [ ] **Architecture**: Is `AppSurface` used instead of `Container`?
  * [ ] **Color System**: Are `AppColorScheme` semantic properties used instead of raw colors?
  * [ ] **Harmonization**: Are Semantic Status/Barrier colors harmonized with the Seed color via Factory logic?
  * [ ] **Motion**: Is `AppMotion` used? Does Pixel mode snap instantly (0ms)?
  * [ ] **Feedback**: Does the component trigger `AppFeedback` on interaction?
  * [ ] **Styles**: Does the component render correctly in Neumorphic (Double Shadow) and Pixel (High Contrast) modes?
  * [ ] **Configurability**: Does the component respect overrides from `AppThemeConfig`?
  * [ ] **Automation**: Is `@TailorMixin` used for all theme extensions?
  * [ ] **Shared Specs**: Does the component style compose `AnimationSpec`, `StateColorSpec`, or `OverlaySpec` instead of duplicating properties?
  * [ ] **State Colors**: Does the component use `StateColorSpec.resolve()` for state-based color resolution?
  * [ ] **Animation Composition**: Does the component use `AnimationSpec` from style instead of hardcoded `Duration`/`Curve`?
  * [ ] **StyleOverride**: Does the component respect `StyleOverride` ancestor for local overrides?
  * [ ] **Testing**: Do Golden Tests use the "Safe Mode" pattern?
  * [ ] **Widgetbook Stories**: Do story files use `.stories.dart` suffix and correct directory structure?
  * [ ] **Typography**: Are `appTextTheme` tokens used instead of hardcoded `TextStyle()`?
  * [ ] **Typography Customization**: Do theme-specific text styles use `.copyWith()` on base tokens?
  * [ ] **Overlay Wrappers**: Do `showAppDialog`/`showAppBottomSheet` wrap content with Theme ‚Üí Portal ‚Üí Material?
  * [ ] **Responsive Edit**: Do edit mode buttons conditionally render based on `isEditing && isDesktop`?