-----

# üìú Flutter UI Component Library Charter (ui\_kit)

**Version**: 3.0.0
**Effective Date**: 2025-12-06
**Scope**: All contributors and maintainers of the UI Library

-----

## 1\. Vision & Scope

This library aims to provide a **High Cohesion, Logic-Free, Configurable** set of UI components. It serves as the **Single Source of Truth** for the application's visual presentation, supporting **Multi-Paradigm Visual Styles** (e.g., Flat, Glass, Pixel, Neumorphic) through a unified configuration system.

  * **Scope**: Atomic components (Atoms), composite components (Molecules), theme definitions (Theming), icon assets (Assets), interaction systems (Motion/Feedback), and layout logic.
  * **Out of Scope**: API connectivity, state management (Bloc/Provider), routing logic, and business data models.

-----

## 2\. Architectural Boundaries

### 2.1 Physical Isolation

The library must exist as an **independent Dart Package**, physically enforced to decouple it from the main app.

### 2.2 Dependency Hygiene

  * ‚ùå **Forbidden**: Dependencies containing business logic or backend connectivity are strictly prohibited (e.g., `bloc`, `provider`, `riverpod`, `http`, `dio`, `firebase`, `shared_preferences`).
  * ‚úÖ **Allowed**: UI and utility packages only (e.g., `flutter`, `intl`, `vector_math`, `google_fonts`, `flutter_svg`, `rive`, `theme_tailor`, `flutter_animate`, `flutter_gen`).

### 2.3 Directory Structure

Adopts a variation of **Atomic Design**:

  * `src/foundation/`: Base styles (Theme Contracts, Colors, Motion, Feedback, Specs).
  * `src/atoms/`: Indivisible minimal units (AppSurface, Button, Icon).
  * `src/molecules/`: Simple combinations (ListTile, InputField, Toggles).
  * `src/organisms/`: Complex blocks (AppBar, ProductCard, BottomSheet).
  * `src/layout/`: Responsive layout helpers.

-----

## 3\. Architectural Core Principles

To maintain long-term maintainability and support multi-style switching, all development must adhere to the following philosophies.

### 3.1 Inversion of Control (IoC)

  * **Definition**: Components must not determine their own specific appearance. Control is inverted to the **Theme**.
  * **Practice**: Components ask the Theme "How should I look?" (e.g., color, shape), never "Who are you?" (e.g., "Are you Brutal style?").

### 3.2 Data-Driven Strategy (DDS)

  * **Definition**: Eliminate hard-coded logic branches when handling structural differences. Use data structures (Specs) instead.
  * **Practice**: Use the **Renderer Pattern**. Components render content based on data within a Spec (e.g., `ToggleStyle`), not `if/else` statements.

### 3.3 Zero Internal Defaults

  * **Definition**: Components **MUST NOT** contain fallback values or default style methods.
  * **Fail Fast**: If a required `ThemeExtension` is missing, the component must explicitly throw an exception to force a configuration fix.

### 3.4 Configuration Injection

  * **Definition**: The generation of the Theme and Color System must strictly adhere to the **"Configuration Priority"** principle.
  * **Rule**:
      * **High Priority (Override)**: Explicit override values passed via `AppThemeConfig` (e.g., `customSignalStrong`, `primary`) must always take precedence.
      * **Low Priority (Derived)**: Derived values generated by the Factory algorithm based on `Seed Color` are only used when no override is present.
  * **Rationale**: Supports both **"Lazy Mode"** (Seed-based generation) and **"Expert Mode"** (Full Customization).

-----

## 4\. Theming & Styling

### 4.1 The Single Source of Truth: AppColorScheme

  * **Rule**: All color access within the system **MUST** occur exclusively through the `AppColorScheme` interface (which unifies Material Standard and App Semantic colors).
  * **Constraint**:
      * ‚ùå **Strictly Prohibited**: Using hardcoded colors like `Colors.red` or `Colors.black` in widgets.
      * ‚ùå **Strictly Prohibited**: Relying directly on Flutter's native `ColorScheme` for styling custom components (except for standard Material widgets). Always prefer `AppColorScheme` semantic properties.

### 4.2 Semantic Layer Architecture

  * **Rule**: Non-Material colors must be categorized into five distinct semantic layers. Mixing layers is prohibited:
    1.  **Structure**: `highContrastBorder`, `subtleBorder`, `styleBackground` (Defines shape/boundaries).
    2.  **Decoration**: `styleShadow`, `glowColor` (Defines depth/lighting).
    3.  **Signal & Data**: `signalStrong`, `signalWeak`, `signalGlow` (Defines data state).
    4.  **State**: `activeFillColor`, `activeContentColor` (Defines interaction feedback).
    5.  **Utility**: `overlayColor` (Defines atmosphere/masking).
  * **Constraint**: **Color Harmonization** is mandatory for Signal and Barrier colors. Pure raw colors (e.g., pure Green/Red) are forbidden; they must be blended with the `Seed Color` to ensure visual consistency.

### 4.3 Design Style Strategies

  * **Rule**: The UI Kit must support and strictly distinguish between four rendering strategies. Widgets must respond to `AppTheme.style` with distinct behaviors:
      * **Flat**: Relies on solid color blocks and standard radii.
      * **Glass**: Relies on Opacity, Blur, and Glow. **Constraint**: Background visibility is mandatory.
      * **Pixel**: Relies on Solid Colors, High Contrast Borders, and Aliased shapes. **Constraint**: Gradients and Blur are strictly prohibited.
      * **Neumorphic**: Relies on Double Shadows (Light/Dark) and Embossed/Debossed effects.

### 4.4 Global Visual Effects

  * **Rule**: An `AppEffectLayer` must be injected at the application root to simulate medium textures.
      * **Glass Mode**: Must apply a **Noise Overlay** to prevent color banding.
      * **Pixel Mode**: Must apply a **CRT Shader** (Scanlines, Vignette, RGB Split).

### 4.5 Automation & Tooling

  * **Theme Tailor**: The `theme_tailor` package with **`@TailorMixin`** MUST be used to generate `ThemeExtension` classes. Hand-writing `copyWith` and `lerp` is prohibited.

### 4.6 Typography

  * Follow the **DRY Principle**. Create a unified `BaseTextStyle` to manage `fontFamily` and package paths.

-----

## 5\. Interaction & Immersion

### 5.1 The Unified Motion System

  * **Rule**: Animation durations and curves **MUST NOT** be hardcoded. They must be retrieved via the `AppMotion` interface (`motion.fast`, `motion.medium`, `motion.slow`).
  * **Style-Aware Behavior**: Motion physics must adapt to the active Design Style:
      * **Pixel Mode**: Must enforce **0ms (Instant Snap)** or **Stepped Curves**. Interpolation is strictly prohibited.
      * **Glass Mode**: Must use Fluid curves (`easeOutExpo`) with longer durations to simulate floating/underwater physics.
      * **Flat/Neumorphic**: Uses standard Material Easing.

### 5.2 The Feedback System

  * **Rule**: All interactive components (Buttons, Toggles, Inputs, Table Edit) must request feedback via the `AppFeedback` interface upon user interaction.
  * **Constraint**:
      * **Pixel Mode**: Must provide **"Heavy Impact"** (strong haptic) and Mechanical/8-bit audio feedback.
      * **Glass Mode**: Must provide **"Crisp/Light"** (light haptic) and Glass/Ethereal audio feedback.

-----

## 6\. Component Design & Primitives

### 6.1 The Primitive: AppSurface

  * **Mandatory Usage**: All visual containers **MUST** compose `AppSurface` as the root or child node.
  * **No Native Containers**: Business components must not directly use `Container` + `BoxDecoration`.

### 6.2 Dumb Components

  * Components receive data via **Constructor** and pass events via **Callback**. They must not hold business state.

### 6.3 Composition over Inheritance

  * Use the **Slots Pattern** (e.g., `child`, `leading`, `trailing`). Avoid monolithic widgets.

-----

## 7\. Expansion Protocols

### 7.1 Component Expansion

  * **Composition First**: Prioritize using `AppSurface`.
  * **No Runtime Checks**: Code **MUST NOT** contain checks like `if (theme is BrutalDesignTheme)`. Use the Renderer Pattern.

### 7.2 Style Expansion

  * **Zero-Touch Policy**: Adding a new style **MUST NOT** require modifying the source code of existing components.
  * **Full Compliance**: New styles must fully implement `AppDesignTheme` and `AppColorScheme`.

-----

## 8\. Assets Management

### 8.1 Access Control

  * **Strong Typing**: String paths are prohibited. Use objects generated by **`flutter_gen`** (e.g., `MyAssets.icons.home`).

### 8.2 Formats

  * **Icons**: Use **SVG** with color control via `IconTheme`.
  * **Pixel Mode**: Icons must switch to Bitmap/Aliased versions or adapt via `AppIcon` logic.

-----

## 9\. Animation Strategy

  * **Micro-interactions**: Use `flutter_animate`.
  * **State-Driven**: Use **Rive**.
  * **Prohibited**: Lottie is not used.

-----

## 10\. Layout & Responsiveness

  * **No Global State**: Use `LayoutBuilder` or `MediaQuery`, never Singletons.
  * **Centralized Config**: Breakpoints and Gutters must be defined in `AppLayout` ThemeExtension.

-----

## 11\. Accessibility & Internationalization

  * **A11y**: Interactive components must wrap `Semantics`. Minimum touch target 44px/48px.
  * **i18n**: No hardcoded strings. All labels must be passed via constructor.

-----

## 12\. Performance

  * **Repaint Boundary**: Wrap frequently changing components (e.g., Loaders) in `RepaintBoundary`.
  * **Expensive Operations**: Use `Opacity` and `BackdropFilter` sparingly (except where mandated by Glass Style).

-----

## 13\. Quality Assurance & Testing

### 13.1 Widgetbook

  * **Mandatory**: All public components must have a UseCase in Widgetbook with configurable Knobs.

### 13.2 Golden Tests

  * **Test Matrix**: Light/Dark x Flat/Glass/Pixel/Neumorphic x Scale 1.0/1.5.
  * **Safe Mode Protocol**: (See Appendix B).

### 13.3 Theme Editor

  * **Integration Verification**: Components must update instantly when theme parameters change in the Theme Editor, verifying adherence to IoC.

-----

## 14\. Governance

### 14.1 Constitution Version

3.0.0

### 14.2 Ratification Date

2025-12-06

### 14.3 Amendment Procedure

Amendments require consensus among core maintainers.

### 14.4 Compliance Review

Adherence will be reviewed during code reviews. Non-compliance must be resolved promptly.

-----

## Appendix A: Developer Implementation Guide

### A.1 Style-Aware Colors

```dart
// ‚úÖ GOOD: Using Semantic Colors
Container(
  decoration: BoxDecoration(
    color: theme.appColors.styleBackground,
    border: Border.all(color: theme.appColors.highContrastBorder),
  )
)
```

### A.2 Unified Motion

```dart
// ‚úÖ GOOD: Using Motion Tokens
AnimatedContainer(
  duration: theme.motion.medium.duration, // 0ms for Pixel, 500ms for Glass
  curve: theme.motion.medium.curve,
  ...
)
```

-----

## Appendix B: Golden Test Standard Protocol

**Goal**: To ensure the **Stability**, **Consistency**, and **Readability** of visual regression tests across the entire UI library.

### B.1 Core Architecture

All Golden Test files must adhere to the following structure to ensure proper resource loading and test matrix generation.

```dart
void main() {
  // 1. Global Setup
  setUpAll(() async {
    // MUST load real fonts. Using Ahem (colored blocks) is prohibited.
    await loadAppFonts();
  });

  group('Component Golden Tests', () {
    // 2. Use the Matrix Factory
    // You MUST use the matrix to generate all 8 styles (4 Themes x 2 Modes) at once.
    goldenTest(
      'Component - State Name',
      fileName: 'component_state_name',
      builder: () => buildThemeMatrix(
        name: 'State Name',
        width: 300.0, // Provide explicit width
        height: 100.0,
        child: ComponentUnderTest(...),
      ),
    );
  });
}
```

### B.2 Safe Mode Protocol

To prevent CI/CD failures, all test scenarios generated by `buildThemeMatrix` (and the underlying `buildSafeScenario`) must enforce the following protections:

1.  **Explicit Constraints (Size Lock)**

      * **Rule**: Every test scenario **MUST** be wrapped in a fixed-size container (e.g., `SizedBox`).
      * **Reason**: Prevents `RenderFlex overflow` errors and `BoxConstraints(biggest)` infinite expansion crashes.
      * **Standard Sizes**:
          * Buttons/Inputs: `width: 300`, `height: 100`
          * Cards: `width: 300`, `height: auto`
          * Screens/Pages: `width: 375`, `height: 667`

2.  **Background Visibility**

      * **Rule**: Every scenario **MUST** wrap the component in a `ColoredBox` injected with `theme.scaffoldBackgroundColor` (derived from `AppColorScheme.styleBackground` or similar).
      * **Reason**:
          * **Glass Theme**: Requires a colored background to show translucency and blur.
          * **Neumorphic Theme**: Requires specific grey tones to show shadow depth.
          * **Pixel Theme**: Requires contrast to show the aliased borders.
          * Transparent backgrounds make these themes invisible or incorrect in screenshots.

3.  **Animation Freezing**

      * **Rule**: Scenarios are wrapped in `TickerMode(enabled: false)` by default.
      * **Exception**: If testing an active animation sequence (e.g., Tooltip popping up), animation must be explicitly enabled, and time must be advanced manually via `pump()`.
      * **Reason**: Prevents timeouts caused by infinite looping animations (e.g., `AppSkeleton` pulse, `AppLoader` spin) blocking `pumpAndSettle`.

### B.3 Interaction Strategy

For components requiring interaction to appear (e.g., Tooltips, Dialogs), prioritize **State Injection** over simulation.

  * **‚úÖ Recommended: State Injection**
      * Expose an `initiallyVisible` or `forceState` parameter in the component.
      * Usage: `AppTooltip(initiallyVisible: true, ...)`
      * **Benefit**: 100% stability, zero race conditions.
  * **‚ö†Ô∏è Alternative: Simulated Interaction**
      * Use only when State Injection is impossible.
      * Must use the `pumpWidget` callback to manually trigger the event.

-----

## Appendix C: Code Review Checklist

Reviewers shall inspect code based on the following:

  * [ ] **Architecture**: Is `AppSurface` used instead of `Container`?
  * [ ] **Color System**: Are `AppColorScheme` semantic properties used instead of raw colors?
  * [ ] **Harmonization**: Are Signal/Barrier colors harmonized with the Seed color via Factory logic?
  * [ ] **Motion**: Is `AppMotion` used? Does Pixel mode snap instantly (0ms)?
  * [ ] **Feedback**: Does the component trigger `AppFeedback` on interaction?
  * [ ] **Styles**: Does the component render correctly in Neumorphic (Double Shadow) and Pixel (High Contrast) modes?
  * [ ] **Configurability**: Does the component respect overrides from `AppThemeConfig`?
  * [ ] **Automation**: Is `@TailorMixin` used for all theme extensions?
  * [ ] **Testing**: Do Golden Tests use the "Safe Mode" pattern?