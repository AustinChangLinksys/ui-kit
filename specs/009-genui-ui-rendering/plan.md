# Implementation Plan: GenUI Phase 2 - UI Rendering & Component Registry Integration

**Branch**: `009-genui-ui-rendering` | **Date**: 2025-12-03 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/009-genui-ui-rendering/spec.md`

## Summary

Build the Presentation Layer for GenUI (the "Limbs") to transform Phase 1's structured `LLMResponse` data into dynamic Flutter widgets. Implement a Registry Pattern for component lookup, Error Boundaries for fault isolation, and state management for loading/error/data states. Enable developers to register UI Kit components without modifying GenUI core, supporting mixed layouts (text + components) with automatic type conversion and graceful fallbacks.

## Technical Context

**Language/Version**: Dart 3.0+, Flutter 3.13+
**Primary Dependencies**: `flutter`, `generative_ui` (Phase 1), `ui_kit_library` (parent package)
**Storage**: N/A (rendering layer, no persistence)
**Testing**: `flutter_test`, `alchemist` (golden tests)
**Target Platform**: Android/iOS (Flutter mobile), Chrome Web (future)
**Project Type**: Single Flutter package (mobile)
**Performance Goals**: Component registry lookup <10ms, state transitions <100ms, smooth 60fps rendering
**Constraints**: No async operations in component builders; must maintain UI Kit design system compliance; all rendered widgets must use `AppSurface` pattern
**Scale/Scope**: 5-7 new widget files, 60-80 tasks across 5 phases, supports 100+ registered components

## Constitution Check

**GATE: Architecture & Dependency Hygiene**

✅ **2.1 Physical Isolation**: GenUI is isolated as `generative_ui` package; Phase 2 adds presentation layer without affecting core
✅ **2.2 Dependency Hygiene**: No forbidden dependencies (bloc, provider, http, firebase); Phase 2 uses only Flutter + Phase 1 entities
✅ **6.1 No Runtime Type Checks**: Uses `is ToolUseBlock` for pattern matching (acceptable), not `runtimeType` checks
✅ **5.3 Composition over Inheritance**: `DynamicWidgetBuilder`, `GenUiContainer` use composition; registry is lookup table, not inheritance
✅ **5.1 AppSurface Mandatory**: All rendered cards must wrap in `AppSurface` for consistency
✅ **12.2 Testing Standards**: Widget tests for state transitions, integration tests for E2E, golden tests for visual regression across 8 themes (Safe Mode protocol)

**Status**: ✅ **APPROVED** - No violations. Clean Architecture maintained. Ready for Phase 0 research.

## Project Structure

### Documentation (this feature)

```text
specs/009-genui-ui-rendering/
├── spec.md                              # Feature specification (done)
├── plan.md                              # This file (Phase 0-1 output)
├── research.md                          # Phase 0: Technology research (to be generated)
├── data-model.md                        # Phase 1: Entity definitions (to be generated)
├── quickstart.md                        # Phase 1: Getting started guide (to be generated)
├── contracts/                           # Phase 1: API contracts (to be generated)
│   ├── component_registry.dart          # Component registry interface
│   ├── widget_builder.dart              # WidgetBuilder typedef contract
│   └── gen_ui_wrapper.dart              # Public API contract
├── checklists/
│   └── requirements.md                  # Quality checklist (done)
└── tasks.md                             # Phase 2: Task breakdown (generated by /speckit.tasks)
```

### Source Code (Flutter Package)

```text
generative_ui/
├── lib/
│   ├── src/
│   │   ├── ... (Phase 1 files: domain, data)
│   │   └── presentation/
│   │       ├── registry/
│   │       │   └── component_registry.dart        # Component lookup table
│   │       ├── widgets/
│   │       │   ├── message_bubble.dart           # TextBlock → chat bubble
│   │       │   ├── fallback_card.dart            # Error/unknown component card
│   │       │   ├── dynamic_builder.dart          # ToolUseBlock → widget rendering
│   │       │   ├── gen_ui_container.dart         # State management & orchestration
│   │       │   └── gen_ui_wrapper.dart           # Public entry point (enhanced)
│   │       └── state/
│   │           └── gen_ui_state.dart             # State model for container
│   ├── generative_ui.dart                        # Library export (updated)
│   └── constants.dart
├── test/
│   ├── presentation/
│   │   ├── registry/
│   │   │   └── component_registry_test.dart      # Registry tests
│   │   └── widgets/
│   │       ├── dynamic_builder_test.dart         # Builder logic tests
│   │       ├── message_bubble_test.dart          # Bubble widget tests
│   │       ├── fallback_card_test.dart           # Fallback card tests
│   │       ├── gen_ui_container_test.dart        # State management tests
│   │       └── gen_ui_container_golden_test.dart # Visual regression tests
│   └── integration/
│       └── rendering_e2e_test.dart               # End-to-end rendering tests
└── pubspec.yaml
```

**Structure Decision**: Extend existing Phase 1 package with new `presentation` layer widgets. Registry pattern separates component lookup from rendering. State management in `GenUiContainer` handles orchestration ↔ UI binding.

## Phase 0: Research (Unknowns & Best Practices)

### Unknown 1: Flutter State Management Strategy

**Question**: Use simple `StatefulWidget.setState` vs. advanced pattern (Bloc, Provider, Riverpod)?

**Research Tasks**:
1. Evaluate setState approach for Phase 2 MVP (simple, minimal dependencies)
2. Document Provider/Riverpod upgrade path for Phase 3
3. Identify state shape for loading/data/error transitions

**Decision**: Use simple `setState` for Phase 2. Phase 3 can upgrade to Provider if needed. Rationale: Reduces dependencies, meets Constitution 2.2 (no forbidden deps), and Phase 2 state is simple (loading, response, error).

### Unknown 2: Type Conversion Strategy

**Question**: How to map JSON types → Dart widget parameters (e.g., `props['ssid']` → `String`, `props['isEnabled']` → `bool`)?

**Research Tasks**:
1. Research Dart reflection libraries and limitations
2. Evaluate manual type mapping vs. code generation
3. Design fallback strategy for type mismatches

**Decision**: Manual type mapping with explicit casting + fallback to error card. Rationale: Simple, no external deps, clear error messages, aligns with Constitution 6.1 (no runtime type checks beyond pattern matching).

### Unknown 3: Error Boundary Implementation

**Question**: How to isolate component rendering errors without affecting sibling widgets?

**Research Tasks**:
1. Research Flutter's `ErrorWidget` and error boundary patterns
2. Evaluate try-catch placement vs. custom widget wrapper
3. Design error state UI that debugs but doesn't leak stack traces

**Decision**: Try-catch in `DynamicWidgetBuilder` per-block, return `FallbackCard` on exception. Rationale: Isolates errors, maintains app stability, provides user-friendly fallback.

### Unknown 4: Golden Testing Setup

**Question**: How to ensure dynamically rendered components pixel-match hardcoded ones across 8 theme combinations?

**Research Tasks**:
1. Research `alchemist` safe mode protocol for dynamic widgets
2. Identify theme matrix (4 themes × 2 brightness = 8 combinations)
3. Design goldens baseline capture strategy

**Decision**: Use `alchemist` with Safe Mode protocol (explicit constraints, background injection, animation freezing). Rationale: Matches UI Kit standards from Phase 1, ensures CI/CD stability.

## Phase 1: Design & Contracts

### Data Model (data-model.md)

Extract key entities:

**GenUiState** (State container for GenUiContainer)
```dart
enum GenUiViewState { initial, loading, data, error }

class GenUiState {
  final GenUiViewState viewState;
  final LLMResponse? response;
  final String? errorMessage;

  GenUiState({
    this.viewState = GenUiViewState.initial,
    this.response,
    this.errorMessage,
  });
}
```

**ComponentRegistry**
- Maps `String componentName` → `WidgetBuilder function`
- Lookup is O(1), supports 100+ components
- Type-safe (returns `WidgetBuilder?`)

**WidgetBuilder** (typedef)
- Signature: `Widget Function(BuildContext, Map<String, dynamic>)`
- No async operations
- May throw exceptions (caught by error boundary)

**ContentBlockUI** (Rendering model)
- `TextBlockUI`: Renders as `MessageBubble`
- `ToolUseBlockUI`: Renders via registry or `FallbackCard`
- `ErrorBlockUI`: Fallback for rendering errors

### API Contracts (contracts/)

**ComponentRegistry Interface**
```dart
abstract class IComponentRegistry {
  void register(String componentName, WidgetBuilder builder);
  WidgetBuilder? lookup(String componentName);
  List<String> getRegisteredComponents();
}
```

**GenUiWrapper Constructor**
```dart
GenUiWrapper({
  required OrchestrateUIFlowUseCase orchestrator,
  required IComponentRegistry registry,
  required VoidCallback? onComplete,
})
```

**WidgetBuilder Typedef**
```dart
typedef WidgetBuilder = Widget Function(
  BuildContext context,
  Map<String, dynamic> props,
);
```

### Quickstart Guide (quickstart.md)

Example: Register WifiSettingsCard and InfoCard

```dart
void main() {
  final registry = ComponentRegistry();

  registry.register('WifiSettingsCard', (context, props) {
    return WifiSettingsCard(
      ssid: props['ssid'] as String? ?? 'Unknown',
      security: props['security'] as String? ?? 'Open',
      isEnabled: props['isEnabled'] as bool? ?? false,
    );
  });

  runApp(MyApp(registry: registry));
}

// Usage:
GenUiWrapper(
  orchestrator: OrchestrateUIFlowUseCase(
    contentGenerator: MockContentGenerator(),
  ),
  registry: registry,
)
```

## Phase 1: Agent Context Update

Run `.specify/scripts/bash/update-agent-context.sh claude` to document:
- Registry Pattern: Lookup table for component factories
- Error Boundaries: Per-widget exception handling
- State Machine: Initial → Loading → Data/Error
- Type Mapping: JSON → Dart parameter conversion

## Complexity Tracking

**No constitutional violations justifying complexity increases.** The design follows established UI Kit patterns:
- Composition over inheritance (registry is composition, not base classes)
- DDS-compatible (registry enables dynamic data-driven component selection)
- No forbidden dependencies
- Error boundaries reduce production risk

All complexity is inherent to feature requirements (dynamic rendering, type conversion, error isolation).

## Risk Mitigation

**Risk 1**: Dynamic component rendering crashes app
- **Mitigation**: Error boundaries catch per-widget exceptions; fallback card prevents cascade

**Risk 2**: JSON props don't match widget parameters
- **Mitigation**: Type conversion with explicit casting; fallback card on mismatch

**Risk 3**: Unknown component freezes UI
- **Mitigation**: Registry returns `null` for unknown; fallback card renders instantly

**Risk 4**: Golden tests fail due to theme variations
- **Mitigation**: Use `alchemist` Safe Mode with explicit constraints + background injection

**Risk 5**: Loading indicator blocks UI interaction
- **Mitigation**: Isolate loading to widget scope; don't block entire app

## Next Steps

1. **Generate research.md** with unknowns resolved (Phase 0)
2. **Generate data-model.md** with entity definitions (Phase 1)
3. **Generate quickstart.md** with developer guide (Phase 1)
4. **Run /speckit.tasks** to generate 60-80 tasks with dependencies (Phase 2)
5. **Implement Phase 2** following task order and parallelization hints

## Success Criteria - Plan Completion

Phase 2 Planning is **complete** when:

- ✅ Technical Context fully specified (no NEEDS CLARIFICATION)
- ✅ Constitution Check passes (6/6 gates)
- ✅ Directory structure defined
- ✅ Phase 0 research tasks identified
- ✅ Data model documented
- ✅ API contracts specified
- ✅ Quickstart example provided
- ✅ Complexity justified
- ✅ Risk mitigation strategies defined
- ✅ Ready for `/speckit.tasks` (task breakdown)

---

**Ready for Phase 0 research and Phase 1 design. Proceed with `/speckit.tasks` to generate detailed task breakdown.**
